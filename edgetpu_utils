import os
import sys
import argparse
import logging
import time
from pathlib import Path

import numpy as np
import cv2

class Colors:
    # Ultralytics color palette https://ultralytics.com/
    def __init__(self):
        # hex = matplotlib.colors.TABLEAU_COLORS.values()
        hex = ('FF3838', 'FF9D97', 'FF701F', 'FFB21D', 'CFD231', '48F90A', '92CC17', '3DDB86', '1A9334', '00D4BB',
               '2C99A8', '00C2FF', '344593', '6473FF', '0018EC', '8438FF', '520085', 'CB38FF', 'FF95C8', 'FF37C7')
        self.palette = [self.hex2rgb('#' + c) for c in hex]
        self.n = len(self.palette)

    def __call__(self, i, bgr=False):
        c = self.palette[int(i) % self.n]
        return (c[2], c[1], c[0]) if bgr else c

    @staticmethod
    def hex2rgb(h):  # rgb order (PIL)
        return tuple(int(h[1 + i:1 + i + 2], 16) for i in (0, 2, 4))

def resize_and_pad(image, desired_size):
    old_size = image.shape[:2] 
    ratio = float(desired_size/max(old_size))
    new_size = tuple([int(x*ratio) for x in old_size])
    
    # new_size should be in (width, height) format
    
    image = cv2.resize(image, (new_size[1], new_size[0]))
    
    delta_w = desired_size - new_size[1]
    delta_h = desired_size - new_size[0]
    
    pad = (delta_w, delta_h)
    
    color = [100, 100, 100]
    new_im = cv2.copyMakeBorder(image, 0, delta_h, 0, delta_w, cv2.BORDER_CONSTANT,
        value=color)
        
    return new_im, pad
     
def get_image_tensor(img, max_size, debug=False):
    """
    Reshapes an input image into a square with sides max_size
    """
    if type(img) is str:
        img = cv2.imread(img)
    
    resized, pad = resize_and_pad(img, max_size)
    resized = resized.astype(np.float32)
    
    if debug:
        cv2.imwrite("intermediate.png", resized)

    # Normalise!
    resized /= 255.0
    
    return img, resized, pad


# Additional code for EMA calculation
def exponential_moving_average(current_value, previous_ema):
    # Initialize variables for EMA
    alpha = 0.2
    if previous_ema is None:
        return current_value
    else:
        return (1 - alpha) * np.mean(previous_ema) + alpha * np.mean(current_value)

# Additional code for removing outliers using Z-score
def remove_outliers(data, z_threshold=3):
    mean = np.mean(data)
    std = np.std(data)
    z_scores = np.abs((data - mean) / std)
    
    # Z-score가 임계값보다 작은 데이터만 유지하여 이상치 제거
    filtered_data = data[z_scores < z_threshold]
    
    return filtered_data

class StreamingDataProcessor:
    def __init__(self, window_size, alpha, z_threshold):
        self.window_size = window_size
        self.data_buffer = []
        self.alpha = alpha
        self.ema_distance = None
        self.z_threshold = z_threshold

    def process_new_data(self, new_distance):
        self.data_buffer.append(new_distance)

        if len(self.data_buffer) >= self.window_size:
            # Remove outliers using Z-score
            data_no_outliers = remove_outliers(np.array(self.data_buffer), self.z_threshold)
            
            # EMA calculation for distance (using data without outliers)
            self.ema_distance = exponential_moving_average(data_no_outliers, self.ema_distance)
            
            # Remove oldest data to maintain window size
            self.data_buffer.pop(0)

    def get_ema_distance(self):
        return self.ema_distance